{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCropSize = getCropSize;\nexports.restrictPosition = restrictPosition;\nexports.getDistanceBetweenPoints = getDistanceBetweenPoints;\nexports.getRotationBetweenPoints = getRotationBetweenPoints;\nexports.computeCroppedArea = computeCroppedArea;\nexports.getInitialCropFromCroppedAreaPixels = getInitialCropFromCroppedAreaPixels;\nexports.getCenter = getCenter;\nexports.rotateAroundMidPoint = rotateAroundMidPoint;\nexports.translateSize = translateSize;\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Compute the dimension of the crop area based on image size,\n * aspect ratio and optionally rotatation\n * @param {number} imgWidth width of the src image in pixels\n * @param {number} imgHeight height of the src image in pixels\n * @param {number} aspect aspect ratio of the crop\n * @param {rotation} rotation rotation in degrees\n */\n\n\nfunction getCropSize(imgWidth, imgHeight, aspect) {\n  var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  var _translateSize = translateSize(imgWidth, imgHeight, rotation),\n      width = _translateSize.width,\n      height = _translateSize.height;\n\n  if (imgWidth >= imgHeight * aspect && width > imgHeight * aspect) {\n    return {\n      width: imgHeight * aspect,\n      height: imgHeight\n    };\n  }\n\n  if (width > imgHeight * aspect) {\n    return {\n      width: imgWidth,\n      height: imgWidth / aspect\n    };\n  }\n\n  if (width > height * aspect) {\n    return {\n      width: height * aspect,\n      height: height\n    };\n  }\n\n  return {\n    width: width,\n    height: width / aspect\n  };\n}\n/**\n * Ensure a new image position stays in the crop area.\n * @param {{x: number, y number}} position new x/y position requested for the image\n * @param {{width: number, height: number}} imageSize width/height of the src image\n * @param {{width: number, height: number}} cropSize width/height of the crop area\n * @param {number} zoom zoom value\n * @param {rotation} rotation rotation in degrees\n * @returns {{x: number, y number}}\n */\n\n\nfunction restrictPosition(position, imageSize, cropSize, zoom) {\n  var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  var _translateSize2 = translateSize(imageSize.width, imageSize.height, rotation),\n      width = _translateSize2.width,\n      height = _translateSize2.height;\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\n\nfunction restrictPositionCoord(position, imageSize, cropSize, zoom) {\n  var maxPosition = imageSize * zoom / 2 - cropSize / 2;\n  return Math.min(maxPosition, Math.max(position, -maxPosition));\n}\n\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\n\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\n * Compute the output cropped area of the image in percentages and pixels.\n * x/y are the top-left coordinates on the src image\n * @param {{x: number, y number}} crop x/y position of the current center of the image\n * @param {{width: number, height: number, naturalWidth: number, naturelHeight: number}} imageSize width/height of the src image (default is size on the screen, natural is the original size)\n * @param {{width: number, height: number}} cropSize width/height of the crop area\n * @param {number} aspect aspect value\n * @param {number} zoom zoom value\n * @param {number} rotation rotation value (in deg)\n * @param {boolean} restrictPosition whether we should limit or not the cropped area\n */\n\n\nfunction computeCroppedArea(crop, imgSize, cropSize, aspect, zoom) {\n  var rotation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var restrictPosition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true; // if the image is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n\n  var limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp;\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((imgSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / imgSize.width * 100),\n    y: limitAreaFn(100, ((imgSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / imgSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / imgSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / imgSize.height * 100 / zoom) // we compute the pixels size naively\n\n  };\n  var widthInPixels = Math.round(limitAreaFn(imgSize.naturalWidth, croppedAreaPercentages.width * imgSize.naturalWidth / 100));\n  var heightInPixels = Math.round(limitAreaFn(imgSize.naturalHeight, croppedAreaPercentages.height * imgSize.naturalHeight / 100));\n  var isImgWiderThanHigh = imgSize.naturalWidth >= imgSize.naturalHeight * aspect; // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the image is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n\n  var croppedAreaPixels = _objectSpread({}, sizePixels, {\n    x: Math.round(limitAreaFn(imgSize.naturalWidth - sizePixels.width, croppedAreaPercentages.x * imgSize.naturalWidth / 100)),\n    y: Math.round(limitAreaFn(imgSize.naturalHeight - sizePixels.height, croppedAreaPercentages.y * imgSize.naturalHeight / 100))\n  });\n\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\n * Ensure the returned value is between 0 and max\n * @param {number} max\n * @param {number} value\n */\n\n\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\n\nfunction noOp(max, value) {\n  return value;\n}\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n * @param {{x: number, y: number, width: number, height: number}} croppedAreaPixels\n * @param {{width: number, height: number, naturalWidth: number, naturelHeight: number}} imageSize width/height of the src image (default is size on the screen, natural is the original size)\n */\n\n\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, imageSize) {\n  var aspect = croppedAreaPixels.width / croppedAreaPixels.height;\n  var imageZoom = imageSize.width / imageSize.naturalWidth;\n  var isHeightMaxSize = imageSize.naturalWidth >= imageSize.naturalHeight * aspect;\n  var zoom = isHeightMaxSize ? imageSize.naturalHeight / croppedAreaPixels.height : imageSize.naturalWidth / croppedAreaPixels.width;\n  var cropZoom = imageZoom * zoom;\n  var crop = {\n    x: ((imageSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((imageSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\n * Return the point that is the center of point a and b\n * @param {{x: number, y: number}} a\n * @param {{x: number, y: number}} b\n */\n\n\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\n/**\n *\n * Returns an x,y point once rotated around xMid,yMid\n * @param {number} x\n * @param {number} y\n * @param {number} xMid\n * @param {number} yMid\n * @param {number} degrees\n */\n\n\nfunction rotateAroundMidPoint(x, y, xMid, yMid, degrees) {\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var radian = degrees * Math.PI / 180; // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n\n  var xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid;\n  var yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid;\n  return [xr, yr];\n}\n/**\n *\n * Returns the new bounding area of a rotated rectangle.\n * @param {number} width\n * @param {number} height\n * @param {number} rotation\n */\n\n\nfunction translateSize(width, height, rotation) {\n  var centerX = width / 2;\n  var centerY = height / 2;\n  var outerBounds = [rotateAroundMidPoint(0, 0, centerX, centerY, rotation), rotateAroundMidPoint(width, 0, centerX, centerY, rotation), rotateAroundMidPoint(width, height, centerX, centerY, rotation), rotateAroundMidPoint(0, height, centerX, centerY, rotation)];\n\n  var _outerBounds$reduce = outerBounds.reduce(function (res, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    return {\n      minX: Math.min(x, 'minX' in res ? res.minX : x),\n      maxX: Math.max(x, 'maxX' in res ? res.maxX : x),\n      minY: Math.min(y, 'minY' in res ? res.minY : y),\n      maxY: Math.max(y, 'maxY' in res ? res.maxY : y)\n    };\n  }, {}),\n      minX = _outerBounds$reduce.minX,\n      maxX = _outerBounds$reduce.maxX,\n      minY = _outerBounds$reduce.minY,\n      maxY = _outerBounds$reduce.maxY;\n\n  return {\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}","map":null,"metadata":{},"sourceType":"script"}