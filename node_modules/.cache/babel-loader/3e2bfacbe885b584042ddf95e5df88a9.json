{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _helpers = require(\"./helpers\");\n\nvar _styles = require(\"./styles\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\n\nvar Cropper =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Cropper, _React$Component);\n\n  function Cropper() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Cropper);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Cropper)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.image = null;\n    _this.container = null;\n    _this.containerRect = {};\n    _this.imageSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false\n    };\n\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n\n    _this.cleanEvents = function () {\n      document.removeEventListener('mousemove', _this.onMouseMove);\n      document.removeEventListener('mouseup', _this.onDragStopped);\n      document.removeEventListener('touchmove', _this.onTouchMove);\n      document.removeEventListener('touchend', _this.onDragStopped);\n    };\n\n    _this.onImgLoad = function () {\n      _this.computeSizes();\n\n      _this.emitCropData();\n\n      _this.setInitialCrop();\n\n      if (_this.props.onImageLoaded) {\n        _this.props.onImageLoaded(_this.imageSize);\n      }\n    };\n\n    _this.setInitialCrop = function () {\n      var initialCroppedAreaPixels = _this.props.initialCroppedAreaPixels;\n\n      if (!initialCroppedAreaPixels) {\n        return;\n      }\n\n      var _getInitialCropFromCr = (0, _helpers.getInitialCropFromCroppedAreaPixels)(initialCroppedAreaPixels, _this.imageSize),\n          crop = _getInitialCropFromCr.crop,\n          zoom = _getInitialCropFromCr.zoom;\n\n      _this.props.onCropChange(crop);\n\n      _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n    };\n\n    _this.computeSizes = function () {\n      if (_this.image) {\n        _this.imageSize = {\n          width: _this.image.width,\n          height: _this.image.height,\n          naturalWidth: _this.image.naturalWidth,\n          naturalHeight: _this.image.naturalHeight\n        };\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : (0, _helpers.getCropSize)(_this.image.width, _this.image.height, _this.props.aspect, _this.props.rotation);\n\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n      }\n\n      if (_this.container) {\n        _this.containerRect = _this.container.getBoundingClientRect();\n      }\n    };\n\n    _this.onMouseDown = function (e) {\n      e.preventDefault();\n      document.addEventListener('mousemove', _this.onMouseMove);\n      document.addEventListener('mouseup', _this.onDragStopped);\n\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n\n    _this.onTouchStart = function (e) {\n      e.preventDefault();\n      document.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n\n      document.addEventListener('touchend', _this.onDragStopped);\n\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onDragStart = function (_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = {\n        x: _this.props.crop.x,\n        y: _this.props.crop.y\n      };\n\n      _this.props.onInteractionStart();\n    };\n\n    _this.onDrag = function (_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y;\n      if (!_this.state.cropSize) return;\n      if (_this.rafDragTimeout) window.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = window.requestAnimationFrame(function () {\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? (0, _helpers.restrictPosition)(requestedPosition, _this.imageSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n\n        _this.props.onCropChange(newPosition);\n      });\n    };\n\n    _this.onDragStopped = function () {\n      _this.cleanEvents();\n\n      _this.emitCropData();\n\n      _this.props.onInteractionEnd();\n    };\n\n    _this.onWheel = function (e) {\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.props.zoom - e.deltaY * _this.props.zoomSpeed / 200;\n\n      _this.setNewZoom(newZoom, point);\n\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          return _this.props.onInteractionStart();\n        });\n      }\n\n      clearTimeout(_this.wheelTimer);\n      _this.wheelTimer = setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          return _this.props.onInteractionEnd();\n        });\n      }, 250);\n    };\n\n    _this.getPointOnContainer = function (_ref3, zoom) {\n      var x = _ref3.x,\n          y = _ref3.y;\n\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    };\n\n    _this.getPointOnImage = function (_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y;\n      var _this$props = _this.props,\n          crop = _this$props.crop,\n          zoom = _this$props.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n\n    _this.setNewZoom = function (zoom, point) {\n      if (!_this.state.cropSize) return;\n\n      var zoomPoint = _this.getPointOnContainer(point);\n\n      var zoomTarget = _this.getPointOnImage(zoomPoint);\n\n      var newZoom = Math.min(_this.props.maxZoom, Math.max(zoom, _this.props.minZoom));\n      var requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y\n      };\n      var newPosition = _this.props.restrictPosition ? (0, _helpers.restrictPosition)(requestedPosition, _this.imageSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.props.onZoomChange && _this.props.onZoomChange(newZoom);\n    };\n\n    _this.emitCropData = function () {\n      if (!_this.state.cropSize) return; // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n\n      var restrictedPosition = _this.props.restrictPosition ? (0, _helpers.restrictPosition)(_this.props.crop, _this.imageSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n\n      var _computeCroppedArea = (0, _helpers.computeCroppedArea)(restrictedPosition, _this.imageSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition),\n          croppedAreaPercentages = _computeCroppedArea.croppedAreaPercentages,\n          croppedAreaPixels = _computeCroppedArea.croppedAreaPixels;\n\n      _this.props.onCropComplete && _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n    };\n\n    _this.recomputeCropPosition = function () {\n      var newPosition = _this.props.restrictPosition ? (0, _helpers.restrictPosition)(_this.props.crop, _this.imageSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.emitCropData();\n    };\n\n    return _this;\n  }\n\n  _createClass(Cropper, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      window.addEventListener('resize', this.computeSizes);\n      this.container.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.container.addEventListener('gesturestart', this.preventZoomSafari);\n      this.container.addEventListener('gesturechange', this.preventZoomSafari); // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n\n      if (this.image && this.image.complete) {\n        this.onImgLoad();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener('resize', this.computeSizes);\n      this.container.removeEventListener('wheel', this.onWheel);\n      this.container.removeEventListener('gesturestart', this.preventZoomSafari);\n      this.container.removeEventListener('gesturechange', this.preventZoomSafari);\n      this.cleanEvents();\n      clearTimeout(this.wheelTimer);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.rotation !== this.props.rotation) {\n        this.computeSizes();\n        this.recomputeCropPosition();\n      } else if (prevProps.aspect !== this.props.aspect) {\n        this.computeSizes();\n      } else if (prevProps.zoom !== this.props.zoom) {\n        this.recomputeCropPosition();\n      }\n    } // this is to prevent Safari on iOS >= 10 to zoom the page\n\n  }, {\n    key: \"getAspect\",\n    value: function getAspect() {\n      var _this$props2 = this.props,\n          cropSize = _this$props2.cropSize,\n          aspect = _this$props2.aspect;\n\n      if (cropSize) {\n        return cropSize.width / cropSize.height;\n      }\n\n      return aspect;\n    }\n  }, {\n    key: \"onPinchStart\",\n    value: function onPinchStart(e) {\n      var pointA = Cropper.getTouchPoint(e.touches[0]);\n      var pointB = Cropper.getTouchPoint(e.touches[1]);\n      this.lastPinchDistance = (0, _helpers.getDistanceBetweenPoints)(pointA, pointB);\n      this.lastPinchRotation = (0, _helpers.getRotationBetweenPoints)(pointA, pointB);\n      this.onDragStart((0, _helpers.getCenter)(pointA, pointB));\n    }\n  }, {\n    key: \"onPinchMove\",\n    value: function onPinchMove(e) {\n      var _this2 = this;\n\n      var pointA = Cropper.getTouchPoint(e.touches[0]);\n      var pointB = Cropper.getTouchPoint(e.touches[1]);\n      var center = (0, _helpers.getCenter)(pointA, pointB);\n      this.onDrag(center);\n      if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout);\n      this.rafPinchTimeout = window.requestAnimationFrame(function () {\n        var distance = (0, _helpers.getDistanceBetweenPoints)(pointA, pointB);\n        var newZoom = _this2.props.zoom * (distance / _this2.lastPinchDistance);\n\n        _this2.setNewZoom(newZoom, center);\n\n        _this2.lastPinchDistance = distance;\n        var rotation = (0, _helpers.getRotationBetweenPoints)(pointA, pointB);\n        var newRotation = _this2.props.rotation + (rotation - _this2.lastPinchRotation);\n        _this2.props.onRotationChange && _this2.props.onRotationChange(newRotation);\n        _this2.lastPinchRotation = rotation;\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props3 = this.props,\n          _this$props3$crop = _this$props3.crop,\n          x = _this$props3$crop.x,\n          y = _this$props3$crop.y,\n          rotation = _this$props3.rotation,\n          zoom = _this$props3.zoom,\n          cropShape = _this$props3.cropShape,\n          showGrid = _this$props3.showGrid,\n          _this$props3$style = _this$props3.style,\n          containerStyle = _this$props3$style.containerStyle,\n          cropAreaStyle = _this$props3$style.cropAreaStyle,\n          imageStyle = _this$props3$style.imageStyle,\n          _this$props3$classes = _this$props3.classes,\n          containerClassName = _this$props3$classes.containerClassName,\n          cropAreaClassName = _this$props3$classes.cropAreaClassName,\n          imageClassName = _this$props3$classes.imageClassName,\n          crossOrigin = _this$props3.crossOrigin;\n      return _react[\"default\"].createElement(_styles.Container, {\n        onMouseDown: this.onMouseDown,\n        onTouchStart: this.onTouchStart,\n        ref: function ref(el) {\n          return _this3.container = el;\n        },\n        \"data-testid\": \"container\",\n        containerStyle: containerStyle,\n        className: containerClassName\n      }, _react[\"default\"].createElement(_styles.Img, {\n        src: this.props.image,\n        ref: function ref(el) {\n          return _this3.image = el;\n        },\n        onLoad: this.onImgLoad,\n        onError: this.props.onImgError,\n        alt: \"\",\n        style: {\n          transform: \"translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"deg) scale(\").concat(zoom, \")\")\n        },\n        imageStyle: imageStyle,\n        className: imageClassName,\n        crossOrigin: crossOrigin\n      }), this.state.cropSize && _react[\"default\"].createElement(_styles.CropArea, {\n        cropShape: cropShape,\n        showGrid: showGrid,\n        style: {\n          width: this.state.cropSize.width,\n          height: this.state.cropSize.height\n        },\n        \"data-testid\": \"cropper\",\n        cropAreaStyle: cropAreaStyle,\n        className: cropAreaClassName\n      }));\n    }\n  }]);\n\n  return Cropper;\n}(_react[\"default\"].Component);\n\nCropper.getMousePoint = function (e) {\n  return {\n    x: Number(e.clientX),\n    y: Number(e.clientY)\n  };\n};\n\nCropper.getTouchPoint = function (touch) {\n  return {\n    x: Number(touch.clientX),\n    y: Number(touch.clientY)\n  };\n};\n\nCropper.defaultProps = {\n  zoom: 1,\n  rotation: 0,\n  aspect: 4 / 3,\n  maxZoom: MAX_ZOOM,\n  minZoom: MIN_ZOOM,\n  cropShape: 'rect',\n  showGrid: true,\n  style: {},\n  classes: {},\n  zoomSpeed: 1,\n  crossOrigin: undefined,\n  restrictPosition: true,\n  onInteractionStart: function onInteractionStart() {},\n  onInteractionEnd: function onInteractionEnd() {}\n};\nvar _default = Cropper;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}